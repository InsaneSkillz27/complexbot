
'use strict';


// Nodejs libs.
var fs = require('fs');
var path = require('path');
var _ = require('lodash');

var file = module.exports = {};

//外部 libs.
file.glob = require('glob');
file.minimatch = require('minimatch');
var iconv = require('iconv-lite');
var util = require('./util');
var rimraf = require('rimraf');

var win32 = process.platform === 'win32';

var unixifyPath = function(filepath) {
  if (win32) {
    return filepath.replace(/\\/g, '/');
  } else {
    return filepath;
  }
};

/*
 *改变当前基本路径
 */
file.setBase = function() {
  var dirpath = path.join.apply(path, arguments);
  process.chdir(dirpath);
};


var processPatterns = function(patterns, fn) {
  
  var result = [];
  
  _.flatten(patterns).forEach(function(pattern) {
    //如果第一个字符是!将被忽略
    var exclusion = pattern.indexOf('!') === 0;
    if (exclusion) { pattern = pattern.slice(1);}
    //找到所有匹配的文件。
    var matches = fn(pattern);
    if (exclusion) {
      result = _.difference(result, matches);
    } else {
      result = _.union(result, matches);
    }
  });
  return result;
};


/*
 *返回所有匹配的文件路径.

 * @param {string|array}patterns 匹配模式
 * @param {string|array}filepaths 文件路径
 * @param options 匹配选项
 * @return array
 */

file.match = function(patterns, filepaths , options) {
  
  //如果模式和文件为空，返回[]
  if (patterns == null || filepaths == null) { 
    return []; 
  }
  
  if (!Array.isArray(patterns)) { patterns = [patterns]; }
  if (!Array.isArray(filepaths)) { filepaths = [filepaths]; }

  if (patterns.length === 0 || filepaths.length === 0) { 
    return []; 
  }
  
  return processPatterns(patterns, function(pattern) {
    return file.minimatch.match(filepaths, pattern, options || {});
  });
};


/**
 * 判断指定的文件与模式是否有匹配的，如果有匹配的路径返回true
 */
file.isMatch = function(patterns, filepaths , options) {
  return file.match.apply(file, arguments).length > 0;
};

// Return an array of all file paths that match the given wildcard patterns.

/**
 * 返回匹配模式的所有文件路径
 * @param patterns 匹配的模式
 * @param options 选项
          {function|statSync文件状态}filter:'boolean',
           cwd : '基本路径'
          }
   @return {array}匹配的文件路径
 */
file.expand = function(patterns , options) {
  
  var matches = processPatterns(patterns, function(pattern) {
        return file.glob.sync(pattern, options); //工作目录下文件
  });
  // Filter result set?
  if (options.filter) {
      matches = matches.filter(function(filepath) {
        filepath = path.join(options.cwd || '', filepath);
        try {
            if (typeof options.filter === 'function') {
                return options.filter(filepath);
            } else {
              // If the file is of the right type and exists, this should work.
              return fs.statSync(filepath)[options.filter]();
            }
        } catch(e) {
            return false;
        }
    });
  }
  return matches;
};

var pathSeparatorRe = /[\/\\]/g;


/**
 * 创建目录.
 * @param dirpath 目录路径
 * @param {option}mode
 */
file.mkdir = function(dirpath, mode) {

  if (mode == null) {
    mode = parseInt('0777', 8) & (~process.umask());
  }
  dirpath.split(pathSeparatorRe).reduce(function(parts, part) {
    parts += part + '/';
    var subpath = path.resolve(parts);
    if (!file.exists(subpath)) {
      try {
        fs.mkdirSync(subpath, mode);
      } catch(e) {
        throw util.error('Unable to create directory "' + subpath + '" (Error code: ' + e.code + ').', e);
      }
    }
    return parts;
  }, '');
};

// Recurse into a directory, executing callback for each file.

/**
 * 递归目录中的文件。
 * @param {string}rootdir 根目录
 * @param {function} callback 处理文件的callback
 * @param option {string} 子目录
 */
file.recurse = function recurse(rootdir, callback, subdir) {
  var abspath = subdir ? path.join(rootdir, subdir) : rootdir;
  fs.readdirSync(abspath).forEach(function(filename) {
    var filepath = path.join(abspath, filename);
    if (fs.statSync(filepath).isDirectory()) {
      recurse(rootdir, callback, unixifyPath(path.join(subdir || '', filename || '')));
    } else {
      callback(unixifyPath(filepath), rootdir, subdir, filename);
    }
  });
};

//默认文件编码
file.defaultEncoding = 'utf8';

/**
 * 读文件，返回文件内容.
 * @param filepath 文件路径
 * @param options 可选的
 *         {encoding:'文件编码'}
 * @return 文件内容
 */
file.read = function(filepath, options) {
  if (!options) { options = {}; }
  var contents;
  try {
    contents = fs.readFileSync(String(filepath));
    if (options.encoding !== null) {
      contents = iconv.decode(contents, options.encoding || file.defaultEncoding);
      if (contents.charCodeAt(0) === 0xFEFF) {
        contents = contents.substring(1);
      }
    }
    return contents;
  } catch(e) {
    util.error('Unable to read "' + filepath + '" file (Error code: ' + e.code + ').', e);
  }
};

/**
 * 读json文件
 * @param filepath 文件路径
 * @param options 可选的
 *         {encoding:'文件编码'}
 * @return json对象
 */
file.readJSON = function(filepath, options) {
  var src = file.read(filepath, options);
  var result;
  try {
    result = JSON.parse(src);
    return result;
  } catch(e) {
    util.error('Unable to parse "' + filepath + '" file (' + e.message + ').', e);
  }
};


/**
 * 写文件.
 *@param filepath 文件路径
 *@param contents 待写入的内容
 *@param options
 *@return 写成功返回true，反之
 */
file.write = function(filepath, contents, options) {
  
  if (!options) { options = {}; }
  file.mkdir(path.dirname(filepath));
  try {
    
    if (!Buffer.isBuffer(contents)) {
      contents = iconv.encode(contents, options.encoding || file.defaultEncoding);
    }
    fs.writeFileSync(filepath, contents);
    return true;
  } catch(e) {
    throw util.error('Unable to write "' + filepath + '" file (Error code: ' + e.code + ').', e);
  }
};


/**
 * 复制文件.
 *@param srcPath 源文件
 *@param destpath 目标文件
 */
file.copy = function(srcpath, destpath, options) {
  if (!options) { options = {}; }
  
  var process = options.process && options.noProcess !== true &&
    !(options.noProcess && file.isMatch(options.noProcess, srcpath));
  
  var readWriteOptions = process ? options : {encoding: null};
  
  var contents = file.read(srcpath, readWriteOptions);
  if (process) {
    try {
      contents = options.process(contents, srcpath);
    } catch(e) {
      throw util.error('Error while processing "' + srcpath + '" file.', e);
    }
  }
  if (contents === false) {
    throw util.error('Unable to cpoy "' + filepath + '" file (Error code: ' + e.code + ').', e);
  } else {
    file.write(destpath, contents, readWriteOptions);
  }
};


/**
 * 递归删除文件、文件夹
 * @param filepath 文件路径
 * @param options 选项
 *        {force:'是否强制删除'}
 */
file.delete = function(filepath, options) {
  filepath = String(filepath);

  if (!options) {
        options = {force: false};
  }

  if (!file.exists(filepath)) {
    //如果文件或目录不存在
    return false;
  }

  // Only delete cwd or outside cwd if --force enabled. Be careful, people!
  if (!options.force) {
    if (file.isPathCwd(filepath)) {
      return false;
    } else if (!file.isPathInCwd(filepath)) {
      return false;
    }
  }

  try {
    rimraf.sync(filepath);
    return true;
  } catch(e) {
    throw util.error('Unable to delete "' + filepath + '" file (' + e.message + ').', e);
  }
};

// True if the file path exists.
file.exists = function() {
  var filepath = path.join.apply(path, arguments);
  return fs.existsSync(filepath);
};

// True if the file is a symbolic link.
file.isLink = function() {
  var filepath = path.join.apply(path, arguments);
  return file.exists(filepath) && fs.lstatSync(filepath).isSymbolicLink();
};

// True if the path is a directory.
file.isDir = function() {
  var filepath = path.join.apply(path, arguments);
  return file.exists(filepath) && fs.statSync(filepath).isDirectory();
};

// True if the path is a file.
file.isFile = function() {
  var filepath = path.join.apply(path, arguments);
  return file.exists(filepath) && fs.statSync(filepath).isFile();
};

// Is a given file path absolute?
file.isPathAbsolute = function() {
  var filepath = path.join.apply(path, arguments);
  return path.resolve(filepath) === filepath.replace(/[\/\\]+$/, '');
};

// Do all the specified paths refer to the same path?
file.arePathsEquivalent = function(first) {
  first = path.resolve(first);
  for (var i = 1; i < arguments.length; i++) {
    if (first !== path.resolve(arguments[i])) { return false; }
  }
  return true;
};

// Are descendant path(s) contained within ancestor path? Note: does not test
// if paths actually exist.
file.doesPathContain = function(ancestor) {
  ancestor = path.resolve(ancestor);
  var relative;
  for (var i = 1; i < arguments.length; i++) {
    relative = path.relative(path.resolve(arguments[i]), ancestor);
    if (relative === '' || /\w+/.test(relative)) { return false; }
  }
  return true;
};

// Test to see if a filepath is the CWD.
file.isPathCwd = function() {
  var filepath = path.join.apply(path, arguments);
  try {
    return file.arePathsEquivalent(process.cwd(), fs.realpathSync(filepath));
  } catch(e) {
    return false;
  }
};

// Test to see if a filepath is contained within the CWD.
file.isPathInCwd = function() {
  var filepath = path.join.apply(path, arguments);
  try {
    return file.doesPathContain(process.cwd(), fs.realpathSync(filepath));
  } catch(e) {
    return false;
  }
};
